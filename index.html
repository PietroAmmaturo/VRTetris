<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component/dist/aframe-look-at-component.min.js"></script>
    <script src="https://unpkg.com/aframe-geometry-merger-component/dist/aframe-geometry-merger-component.min.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VR Tour Generator</title>
  </head>
  <body>
    <script>
        let score = 0;

        AFRAME.registerComponent('fire-event-on-collision', {
            schema: {
                objects: { type: 'string', default: '.collidable' },
                eventName: { type: 'string', default: 'collision' },
                propagateTo: { type: 'string', default: '[falling]'},
                minYDistance: { type: 'number', default: 1.5 } // Minimum distance on the y-axis
            },
            tick: function () {
                const me = new THREE.Box3().setFromObject(this.el.object3D);
                const collidables = document.querySelectorAll(this.data.objects);
                
                const myCenter = new THREE.Vector3(); // Create a vector to store the center
                me.getCenter(myCenter);
                collidables.forEach((el) => {
                    const boxCenter = new THREE.Vector3(); // Create a vector to store the center
                    const box = new THREE.Box3().setFromObject(el.object3D);

                    // Calculate the center of the bounding box and store it in myCenter
                    box.getCenter(boxCenter);

                    if (boxCenter.x != myCenter.x || boxCenter.y != myCenter.y) return;
                    if (myCenter.z < boxCenter.z) return;

                    // Calculate the vertical (y-axis) distance between centers
                    const yDistance = myCenter.z - boxCenter.z;

                    // Check for collision if the y-axis distance is below the threshold
                    if (yDistance < this.data.minYDistance) {
                        const target = document.querySelector(this.data.propagateTo);
                        this.el.emit(this.data.eventName);
                        if (target) target.emit(this.data.eventName);
                        this.el.removeAttribute('fire-event-on-collision');
                    }
                });
            },
        });

        AFRAME.registerComponent('join-and-restart-on-collision', {
            schema: {
                wrapper: { type: 'selector', default: '#main' },
                targets: { type: 'string', default: 'a-box' },
                startingPoint: { type: 'string', default: '0 0 10' }
            },
            init: function () {
                const el = this.el;
                const wrapper = this.data.wrapper;

                el.addEventListener('collision', () => {
                    if (el.hasAttribute('piece')) el.removeAttribute('piece'); else return;
                    [...el.querySelectorAll(this.data.targets)].forEach(child => {
                        const stillChild = document.createElement('a-entity');
                        const oldPos = child.getAttribute('position');
                        stillChild.setAttribute('position', {
                            x: el.object3D.position.x + oldPos.x,
                            y: el.object3D.position.y + oldPos.y,
                            z: Math.round(el.object3D.position.z + oldPos.z)
                        });
                        stillChild.setAttribute('material', child.getAttribute('material'));
                        stillChild.setAttribute('material', 'opacity', 1);
                        stillChild.setAttribute('geometry', child.getAttribute('geometry'));
                        stillChild.classList.add('collidable');
                        stillChild.classList.add('piece');
                        this.data.wrapper.appendChild(stillChild);
                        score++;
                    });
                    const pieceEl = document.createElement('a-entity');
                    pieceEl.setAttribute('position', this.data.startingPoint);
                    pieceEl.setAttribute("piece", '');
                    wrapper.appendChild(pieceEl);
                    el.parentNode.removeChild(el);
                });
            },
        });

        AFRAME.registerComponent('falling', {
            schema: {
                speed: { default: 0.001 }
            },
            init: function () {
            },
            tick: function (time, deltaTime) {
                // Move the camera downwards
                const currentPosition = this.el.getAttribute('position');
                const newPosition = {
                    x: currentPosition.x,
                    y: currentPosition.y,
                    z: currentPosition.z - (this.data.speed * deltaTime)
                };
                this.el.setAttribute('position', newPosition);
            }
        });

        AFRAME.registerComponent('piece', {
            schema: {
                pieceTimeout: { default: 100 },
                fallingTimeout: { default: 200 },
                controlsTimeout: { default: 200 },
                maxSize: { default: 2 },
                slotSize: { default: 1 },
            },
            init: function () {
                const cameraEl = document.createElement('a-entity');
                this.el.appendChild(cameraEl);
                cameraEl.setAttribute('position', '0 0 5');
                cameraEl.setAttribute('camera', 'active: true;');
                setTimeout(() => {
                    this.el.setAttribute('join-and-restart-on-collision', '');
                    
                    const heigth = Math.floor(Math.random() * this.data.maxSize) + 1;
                    const width = Math.floor(Math.random() * this.data.maxSize) + 1;
                    const depth = Math.floor(Math.random() * this.data.maxSize) + 1;

                    // Generate a random color
                    const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);

                    for (let i = 0; i < width; i++) {
                        for (let j = 0; j < heigth; j++) {
                            for (let k = 0; k < depth; k++) {
                                const box = document.createElement('a-box');
                                // Set the color and opacity
                                box.setAttribute('material', {
                                    color: randomColor,
                                    opacity: 0.2
                                });
                                box.setAttribute('position', {
                                    x: i,
                                    y: -j,
                                    z: k
                                });
                                box.setAttribute('scale', {
                                    x: this.data.slotSize,
                                    y: this.data.slotSize,
                                    z: this.data.slotSize
                                });
                                box.setAttribute('fire-event-on-collision', '');
                                box.setAttribute('highlight-edges', '');
                                this.el.appendChild(box);
                            }
                        }
                    }
                }, this.data.pieceTimeout);
                setTimeout(() => {
                    this.el.setAttribute('falling', '');
                }, this.data.fallingTimeout);
                setTimeout(() => {
                    this.el.setAttribute('snapping-controls', '');
                }, this.data.controlsTimeout);
            },
        });

        AFRAME.registerComponent('snapping-controls', {
            schema: {
                snapValue: { default: 1 },
                border: { default: 2 },
                moveKeys: { default: ['w', 'a', 's', 'd'] },
                rotateKeys: { default: ['q', 'e'] },
                active: { default: true },
                targets: { default: 'a-box'},
                fastKey: { default: 'Shift'},
                collidables: { default: '.collidable'}
            },
            init: function () {
                this.movingDirection = new THREE.Vector3();
                this.minX = -this.data.border * this.data.snapValue;
                this.maxX = this.data.border * this.data.snapValue;
                this.minY = -this.data.border * this.data.snapValue;
                this.maxY = this.data.border * this.data.snapValue;
                document.addEventListener('keydown', this.onKeyDown.bind(this));
                document.addEventListener('keyup', this.onKeyUp.bind(this));
            },
            onKeyDown: function (event) {
                if (!this.data.active) return;
                const key = event.key;
                if (this.data.moveKeys.includes(key)) {
                    event.preventDefault();
                    this.move(key);
                } else if (this.data.rotateKeys.includes(key)) {
                    event.preventDefault();
                    this.rotate(key);
                } else if (this.data.fastKey == key) {
                    event.preventDefault();
                    if (this.el.getAttribute('falling'))
                    this.el.setAttribute('falling', 'speed', 0.01);
                }
            },
            onKeyUp: function (event) {
                if (!this.data.active) return;
                const key = event.key;
                if (this.data.fastKey == key) {
                    event.preventDefault();
                    if (this.el.getAttribute('falling'))
                    this.el.setAttribute('falling', 'speed', 0.001);
                }
            },
            move: function (key) {
                switch (key) {
                    case this.data.moveKeys[0]:
                        this.moveEntity(0, this.data.snapValue);
                        break;
                    case this.data.moveKeys[1]:
                        this.moveEntity(-this.data.snapValue, 0);
                        break;
                    case this.data.moveKeys[2]:
                        this.moveEntity(0, -this.data.snapValue);
                        break;
                    case this.data.moveKeys[3]:
                        this.moveEntity(this.data.snapValue, 0);
                        break;
                    default:
                        break;
                }
            },
            rotate: function (key) {
                switch (key) {
                    case this.data.rotateKeys[0]:
                        this.rotateEntity(Math.PI / 2);
                        break;
                    case this.data.rotateKeys[1]:
                        this.rotateEntity(-Math.PI / 2);
                        break;
                    default:
                        break;
                }
            },
            rotateEntity: function (deltaRad) {
                const oldParentPosition = this.el.getAttribute('position');
                const children = this.el.querySelectorAll(this.data.targets);
                const collidables  = document.querySelectorAll(this.data.collidables);
                const rotationMatrix = new THREE.Matrix4().makeRotationZ(deltaRad);

                const newChildPositionsRelativeToParent = Array.from(children).map(child => {
                    const oldChildPosition = child.getAttribute('position');
                        // Clone the position to avoid modifying the original object
                    const newChildPosition = { x: oldChildPosition.x, y: oldChildPosition.y, z: oldChildPosition.z };
                    const rotatedPosition = new THREE.Vector3(oldChildPosition.x, oldChildPosition.y, oldChildPosition.z);
                    rotatedPosition.applyMatrix4(rotationMatrix);
                    return {
                        x: rotatedPosition.x,
                        y: rotatedPosition.y,
                        z: rotatedPosition.z // Keep the z position unchanged
                    };
                });
                const newChildPositions = Array.from(newChildPositionsRelativeToParent).map(pos => {
                    return {
                        x: oldParentPosition.x + pos.x,
                        y: oldParentPosition.y + pos.y,
                        z: oldParentPosition.z + pos.z // Keep the z position unchanged
                    };
                });
                if (!this.checkPositions(newChildPositions, collidables)) return;

                for (let i = 0; i < children.length; i++) children[i].setAttribute('position', newChildPositionsRelativeToParent[i]);
            },
            moveEntity: function (deltaX, deltaY) {
                const oldParentPosition = this.el.getAttribute('position');
                const children = this.el.querySelectorAll(this.data.targets);
                const collidables  = document.querySelectorAll(this.data.collidables);
                const newChildPositions = Array.from(children).map(child => {
                    const oldChildPosition = child.getAttribute('position');
                    return {
                        x: oldParentPosition.x + oldChildPosition.x + deltaX,
                        y: oldParentPosition.y + oldChildPosition.y + deltaY,
                        z: oldParentPosition.z + oldChildPosition.z // Keep the z position unchanged
                    };
                });
                if (!this.checkPositions(newChildPositions, collidables)) return;
                this.el.object3D.position.copy({x: oldParentPosition.x + deltaX, y: oldParentPosition.y + deltaY, z: oldParentPosition.z});
            },
            checkPositions: function (newChildPositions, collidables) {
                for (let i = 0; i < newChildPositions.length; i++) {
                    if (newChildPositions[i].x > this.maxX || newChildPositions[i].x < this.minX || newChildPositions[i].y > this.maxY || newChildPositions[i].y < this.minY) return false;
                    for (let j = 0; j < collidables.length; j++) {
                        const collPos = new THREE.Vector3();
                        collidables[j].object3D.getWorldPosition(collPos);
                        const collV = {x: collPos.x, y:  collPos.y, z:  collPos.z};
                        const newV = {x: newChildPositions[i].x, y: newChildPositions[i].y, z: Math.round(newChildPositions[i].z)};
                        if (collV.x == newV.x && collV.y == newV.y && collV.z == newV.z) return false;
                    }
                }
                return true;
            }
        });

        AFRAME.registerComponent('highlight-edges', {
            init: function () {
                const boxGeometry = this.el.getAttribute('geometry');
                if (boxGeometry && boxGeometry.primitive === 'box') {
                    this.highlightEdges(boxGeometry.width, boxGeometry.height, boxGeometry.depth);
                }
            },
            highlightEdges: function (width, height, depth) {
                // Define the corner points of the box
                const corners = [
                    { x: -width / 2, y: -height / 2, z: -depth / 2 },
                    { x: width / 2, y: -height / 2, z: -depth / 2 },
                    { x: -width / 2, y: height / 2, z: -depth / 2 },
                    { x: width / 2, y: height / 2, z: -depth / 2 },
                    { x: -width / 2, y: -height / 2, z: depth / 2 },
                    { x: width / 2, y: -height / 2, z: depth / 2 },
                    { x: -width / 2, y: height / 2, z: depth / 2 },
                    { x: width / 2, y: height / 2, z: depth / 2 }
                ];

                // Define pairs of corner points that represent the edges
                const edgePairs = [
                    [0, 1], [0, 2], [1, 3], [2, 3],
                    [4, 5], [4, 6], [5, 7], [6, 7],
                    [0, 4], [1, 5], [2, 6], [3, 7]
                ];

                // Create line entities to represent the edges
                for (const pair of edgePairs) {
                    const startPoint = corners[pair[0]];
                    const endPoint = corners[pair[1]];

                    const line = document.createElement('a-entity');
                    line.setAttribute('line', {
                        start: `${startPoint.x} ${startPoint.y} ${startPoint.z}`,
                        end: `${endPoint.x} ${endPoint.y} ${endPoint.z}`,
                        color: this.el.getAttribute('material').color
                    });

                    this.el.appendChild(line);
                }
            }
        });

        AFRAME.registerComponent('floor', {
            schema: {
                border: { type: 'number', default: 2 }, // Size of the grid (nxn)
                boxColor: { type: 'color', default: '#444444' } // Black color
            },
            init: function () {
                const offset = this.data.border;
                const boxColor = this.data.boxColor;

                for (let x = -offset; x <= offset; x++) {
                    for (let y = -offset; y <= offset; y++) {
                        const box = document.createElement('a-box');
                        box.setAttribute('position', `${x} ${y} 0`);
                        box.setAttribute('width', 1);
                        box.setAttribute('height', 1);
                        box.setAttribute('depth', 1);
                        box.setAttribute('color', boxColor);
                        box.classList.add('collidable');
                        this.el.appendChild(box);
                    }
                }
            }
        });

        AFRAME.registerComponent('group-deletion', {
            schema: {
                selector: { default: '.piece' },
                requiredCount: { default: 25 },
            },

            init: function () {
                this.checkGroup();
            },

            checkGroup: function () {
                const elements = Array.from(this.el.querySelectorAll(this.data.selector));

                if (elements.length >= this.data.requiredCount) {

                    let foundCounter = 0;
                    // Create a dictionary to group elements by z position
                    const groupedElements = new Map();

                    // Iterate through each element and group them by z position
                    elements.forEach(element => {
                        const zPosition = element.object3D.position.z;
                        
                        if (!groupedElements.has(zPosition)) {
                            groupedElements.set(zPosition, []);
                        }
                        
                        groupedElements.get(zPosition).push(element);
                    });

                    // Extract and sort the z positions
                    const sortedZPositions = Array.from(groupedElements.keys())
                        .map(parseFloat) // Convert keys to numbers
                        .sort((a, b) => a - b);

                    sortedZPositions.forEach(position => {
                        const group = groupedElements.get(position);
                        // lower higher elements
                        if (foundCounter > 0) group.forEach(groupElement => groupElement.object3D.position.z -= 1);
                        // delete the group and increase the counter
                        if (group.length >= this.data.requiredCount) {
                            group.forEach(groupElement => groupElement.parentNode.removeChild(groupElement));
                            foundCounter++;
                        }
                    })
                }
            },
            
            
            tick: function (time, timeDelta) {
                // Call the checkGroup function on each tick for real-time updates
                this.checkGroup();
            },
        });
        
        AFRAME.registerComponent('heigth-check', {
            schema: {
                selector: { default: '.piece' },
                maxHeigth: { default: 10 },
            },

            init: function () {
                this.end = false;
                this.checkHeigth();
            },

            checkHeigth: function () {
                if (this.end) return;
                const elements = Array.from(this.el.querySelectorAll(this.data.selector));
                for (const element of elements) {
                    if (element.object3D.position.z >= this.data.maxHeigth) {
                        this.end = true;
                        if(!window.alert('GAME OVER, SCORE: ' + score)){window.location.reload();}
                        break;
                    }
                }
            },
            
            
            tick: function (time, timeDelta) {
                // Call the checkGroup function on each tick for real-time updates
                this.checkHeigth();
            },
        });
    </script>
    <a-scene>
        <a-sky color="black"></a-sky>
        <a-entity id="main" floor group-deletion heigth-check>
            <a-entity piece snapping-controls id="start" position = "0 0 10">
            </a-entity>
        </a-entity>
    </a-scene>
</html>
